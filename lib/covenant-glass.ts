/**
 * ğŸ”® COVENANT LOOKING GLASS
 * 
 * Analyzes the covenant foundation and searches for missing pieces
 */

import { CovenantFoundation, GUARDIAN_MAPPINGS, KEY_MAP } from './covenant-foundation';
import { BraveSearchClient, BraveSearchResult } from './brave-search';

export interface FoundPiece {
  type: 'contract' | 'quest' | 'guardian' | 'treasure' | 'documentation';
  name: string;
  address?: string;
  url?: string;
  description: string;
  covenant_mapping?: {
    path?: number;
    glyph?: string;
    rootchain?: number;
  };
}

export interface AssembledIntegration {
  pieces: FoundPiece[];
  mappings: {
    guardians: number;
    contracts: number;
    quests: number;
  };
  code: string;
}

export class CovenantGlass {
  private covenant: CovenantFoundation;
  private braveSearch: BraveSearchClient;

  constructor(braveApiKey?: string) {
    this.covenant = new CovenantFoundation();
    this.braveSearch = new BraveSearchClient(braveApiKey);
  }

  /**
   * Analyze the covenant foundation
   */
  analyzeFoundation() {
    return {
      status: this.covenant.getStatus(),
      guardians: this.covenant.getAllGuardians(),
      keyMap: this.covenant.keyMap,
      oracle: this.covenant.getOracle(),
      treasury: this.covenant.getTreasury()
    };
  }

  /**
   * Find missing pieces using Brave API
   */
  async findMissingPieces(): Promise<FoundPiece[]> {
    const results = await this.braveSearch.findMissingPieces();
    const pieces: FoundPiece[] = [];

    // Process contract results
    for (const result of results.contracts) {
      pieces.push({
        type: 'contract',
        name: result.title,
        url: result.url,
        description: result.description
      });
    }

    // Process quest results
    for (const result of results.quests) {
      pieces.push({
        type: 'quest',
        name: result.title,
        url: result.url,
        description: result.description,
        covenant_mapping: {
          rootchain: this.covenant.getConstant('THEOS') // Quest multiplier
        }
      });
    }

    // Process legion results with guardian mappings
    for (const result of results.legions) {
      // Try to match with known guardians
      const guardianPath = this.matchLegionToGuardian(result.title);
      
      pieces.push({
        type: 'guardian',
        name: result.title,
        url: result.url,
        description: result.description,
        covenant_mapping: guardianPath ? {
          path: guardianPath.path,
          glyph: guardianPath.glyph,
          rootchain: guardianPath.value
        } : undefined
      });
    }

    return pieces;
  }

  /**
   * Match a legion name to a guardian path
   */
  private matchLegionToGuardian(legionName: string) {
    const lowerName = legionName.toLowerCase();
    
    // Check known mappings first
    for (const [pathNum, data] of Object.entries(GUARDIAN_MAPPINGS.paths)) {
      if (lowerName.includes(data.legion.toLowerCase())) {
        const path = parseInt(pathNum);
        // Return guardian from guardians.all which has all properties including path
        return this.covenant.getAllGuardians()[path - 1];
      }
    }

    return null;
  }

  /**
   * Assemble all found pieces into complete integration
   */
  async assemblePieces(): Promise<AssembledIntegration> {
    const pieces = await this.findMissingPieces();
    
    const mappings = {
      guardians: pieces.filter(p => p.type === 'guardian').length,
      contracts: pieces.filter(p => p.type === 'contract').length,
      quests: pieces.filter(p => p.type === 'quest').length
    };

    const code = this.generateIntegrationCode(pieces);

    return { pieces, mappings, code };
  }

  /**
   * Generate TypeScript integration code from found pieces
   */
  private generateIntegrationCode(pieces: FoundPiece[]): string {
    const contracts = pieces.filter(p => p.type === 'contract');
    const guardians = pieces.filter(p => p.type === 'guardian');
    const quests = pieces.filter(p => p.type === 'quest');

    return `/**
 * ğŸ”® BRIDGEWORLD INTEGRATION - Auto-Generated
 * Generated by Covenant Looking Glass
 */

import { CovenantFoundation } from './covenant-foundation';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONTRACTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export const BRIDGEWORLD_CONTRACTS = {
${contracts.map(c => `  // ${c.name}\n  // ${c.description}`).join('\n\n')}
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GUARDIANS (${guardians.length}/22)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export const BRIDGEWORLD_GUARDIANS = [
${guardians.map(g => `  {
    name: "${g.name}",
    url: "${g.url}",
    covenant: ${JSON.stringify(g.covenant_mapping, null, 4)}
  }`).join(',\n')}
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// QUESTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export const BRIDGEWORLD_QUESTS = {
${quests.map(q => `  // ${q.name}\n  // ${q.description}`).join('\n\n')}
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INTEGRATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export class BridgeworldIntegration {
  private covenant: CovenantFoundation;

  constructor() {
    this.covenant = new CovenantFoundation();
  }

  /**
   * Calculate quest rewards with THEOS multiplier
   */
  calculateQuestReward(baseReward: number): number {
    return this.covenant.questMultiplier(baseReward);
  }

  /**
   * Calculate harvester boost with EL multiplier
   */
  calculateHarvesterBoost(baseRate: number): number {
    return this.covenant.harvesterBoost(baseRate);
  }

  /**
   * Get mining frequency
   */
  getMiningFrequency(): number {
    return this.covenant.getResonance(); // ${this.covenant.getConstant('RESONANCE')} seconds
  }
}

export default BridgeworldIntegration;
`;
  }

  /**
   * Search for specific Bridgeworld component
   */
  async searchComponent(query: string): Promise<BraveSearchResult[]> {
    return this.braveSearch.searchBridgeworld(query);
  }

  /**
   * Get coordinate mappings from Key and Map
   */
  getCoordinateMappings() {
    return {
      key: KEY_MAP.key,
      map: KEY_MAP.map,
      decoded: KEY_MAP.decoded,
      alignmentThreshold: 200, // pixels for portal activation
      portalCenter: { x: 0.5, y: 0.5 } // viewport center
    };
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXPORTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export default CovenantGlass;
